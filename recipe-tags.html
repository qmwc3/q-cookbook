---
layout: null
permalink: /recipe-tags/
---
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tags Filter - {{ site.title }}</title>
  <link rel="stylesheet" href="{{ '/assets/css/main.css' | relative_url }}">
  <link rel="icon" type="image/png" href="{{ '/assets/favicon.png' | relative_url }}">
</head>
  
<body>
  
  {% include header %}

  <main class="wrap">

    <div class="tags-section">
      <h3>Dish Type</h3>
      <div id="dish-tags" class="tags"></div>
    </div>

    <div class="tags-section" style="margin-top:20px;">
      <h3>Cooking Method</h3>
      <div id="method-tags" class="tags"></div>
    </div>
    
    <div class="tags-section" style="margin-top:20px;">
      <h3>Cuisine</h3>
      <div id="cuisine-tags" class="tags"></div>
    </div>

    <ul id="tag-results" class="recipe-list"></ul>
  
  </main>

  {% include footer %}

<script>

// Display labels
const TAG_DISPLAY = {
  "1-pot": "1-Pot",
  "slow-cooker": "Slow Cooker",
  "sheet-pan": "Sheet Pan",
  "bread": "Bread",
  "breakfast": "Breakfast",
  "dishes": "Dishes",
  "sauce-dip": "Sauce/Dip",
  "dessert": "Dessert",
  "side": "Side",
  "snack": "Snack",
  "soup": "Soup",
  "asian": "Asian",
  "italian": "Italian",
  "mediterranean": "Mediterranean",
  "mexican": "Mexican"
};

// Tag grouping
const TAG_GROUPS = {
  dish: [
    "bread",
    "breakfast",
    "dishes",
    "sauce-dip",
    "dessert",
    "side",
    "snack",
    "soup"
  ],
  method: [
    "1-pot",
    "slow-cooker",
    "sheet-pan"
  ],
  cuisine: [
    "asian",
    "italian",
    "mediterranean",
    "mexican"
  ]
};

document.addEventListener('DOMContentLoaded', function () {

  const results = document.getElementById('tag-results');
  const dishContainer = document.getElementById('dish-tags');
  const methodContainer = document.getElementById('method-tags');
  const cuisineContainer = document.getElementById('cuisine-tags');

  let recipes = [];
  let activeTags = new Set();

  const indexUrl = '{{ "/recipes.json" | relative_url }}';
  const baseUrl = '{{ "/recipe-tags/" | relative_url }}';

  fetch(indexUrl)
    .then(r => { if (!r.ok) throw new Error('Fetch failed'); return r.json(); })
    .then(data => {
      recipes = data;
      renderTags();

      const params = new URLSearchParams(window.location.search);
      const tagsParam = params.get('tags');
      if(tagsParam) {
        tagsParam.split(',').forEach(tag =>
          activeTags.add(decodeURIComponent(tag))
        );
        filterByTags();
      }
    })
    .catch(err => console.error('Failed to load recipes.json', err));

  function renderTags() {
    // Clear containers
    dishContainer.innerHTML = '';
    methodContainer.innerHTML = '';
    cuisineContainer.innerHTML = '';
  
    // Filter recipes based on active tags
    const filteredRecipes = activeTags.size === 0
      ? recipes
      : recipes.filter(r => {
          const rTags = (r.tags || []).map(t => t.toLowerCase());
          return [...activeTags].every(t => rTags.includes(t));
        });
  
    // Count tags in the filtered recipes
    const tagCounts = {};
    filteredRecipes.forEach(r => {
      (r.tags || []).forEach(t => {
        const tag = t.toLowerCase();
        tagCounts[tag] = (tagCounts[tag] || 0) + 1;
      });
    });
  
    // Render buttons for all tags
    Object.keys(TAG_DISPLAY).forEach(name => {
      const display = TAG_DISPLAY[name] || name;
      const count = tagCounts[name] || 0;
  
      const btn = document.createElement('button');
      btn.className = 'tag';
      btn.type = 'button';
      btn.dataset.tag = name;
      btn.textContent = `${display} (${count})`;
  
      // Toggle tag selection
      btn.onclick = () => {
        if (activeTags.has(name)) activeTags.delete(name);
        else activeTags.add(name);
  
        updateURL();
        filterByTags();
        renderTags(); // Re-render to update counts
      };
  
      // Append button to the correct section
      if (TAG_GROUPS.dish.includes(name)) {
        dishContainer.appendChild(btn);
      } else if (TAG_GROUPS.method.includes(name)) {
        methodContainer.appendChild(btn);
      } else if (TAG_GROUPS.cuisine.includes(name)) {
        cuisineContainer.appendChild(btn);
      }
    });
  
    // Highlight active tags
    highlightActiveTags();
  
    // Always show all sections
    dishContainer.parentElement.style.display = '';
    methodContainer.parentElement.style.display = '';
    cuisineContainer.parentElement.style.display = '';
  }

  function filterByTags() {

    results.innerHTML = '';
    highlightActiveTags();

    if(activeTags.size === 0) return;

    const filtered = recipes.filter(r => {
      const rTags = (r.tags || []).map(t => t.toLowerCase());
      return [...activeTags].every(t => rTags.includes(t));
    });

    if(filtered.length === 0) {
      results.innerHTML = '<p>No recipes found matching selected tags.</p>';
    } else {
      filtered.forEach(r => {
        const li = document.createElement('li');
        li.innerHTML = `<a href="${r.url}">${r.title}</a>`;
        results.appendChild(li);
      });
    }
  }

  function highlightActiveTags() {
    const buttons = document.querySelectorAll('.tag');
    buttons.forEach(btn => {
      if(activeTags.has(btn.dataset.tag)) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
    });
  }

  function updateURL() {
    const params = new URLSearchParams();
    if(activeTags.size > 0) {
      params.set('tags', [...activeTags].map(encodeURIComponent).join(','));
    }
    const newUrl = baseUrl + (params.toString() ? '?' + params.toString() : '');
    history.pushState({}, '', newUrl);
  }

  window.addEventListener('popstate', () => {
    const params = new URLSearchParams(window.location.search);
    activeTags = new Set();
    const tagsParam = params.get('tags');
    if(tagsParam) {
      tagsParam.split(',').forEach(tag =>
        activeTags.add(decodeURIComponent(tag))
      );
    }
    filterByTags();
  });

});
</script>

</body>
</html>
